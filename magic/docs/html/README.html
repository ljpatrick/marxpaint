<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Creating Tux Paint Magic Tool Plugins</title>
<meta http-equiv="Content-Type" content="text/html; charset=us-ascii">
</head>

<body bgcolor="#FFFFFF" text="#000000" link="#0000FF" vlink="#FF0000"
alink="#FF00FF">

<center>
<h1>Creating Tux Paint Magic Tool Plugins</h1>

<p>Copyright 2007-2007 by Bill Kendrick and others<br>
New Breed Software</p>

<p><a href="mailto:bill@newbreedsoftware.com">bill@newbreedsoftware.com</a><br>
<a href="http://www.tuxpaint.org/">http://www.tuxpaint.org/</a></p>

<p>July 5, 2007 - July 6, 2007</p>
</center>

<hr size=2 noshade>

<h2>Overview</h2>

<blockquote>

<p>Beginning with version 0.9.18, Tux&nbsp;Paint's 'Magic' tools were converted
from routines that lived within the application itself, to a set of 'plugins'
that are loaded when Tux&nbsp;Paint starts up.</p>

<p>This division allows more rapid development of 'Magic' tools, and allows
programmers to create and test new tools without needing to integrate them
within the main Tux&nbsp;Paint source code.  (Users of more professional
graphics tools, such as The&nbsp;GIMP, should be familiar with this plugin
concept.)</p>

</blockquote>

<hr size=1 noshade>

<h2>Prerequisites</h2>

<blockquote>

<p>Tux Paint is written in the C programming language, and uses the
Simple&nbsp;DirectMedia&nbsp;Layer library ('libSDL', or simply 'SDL').
Therefore, for the moment at least, one must understand the C language,
how to compile C-based programs.  Familiarity with the SDL API is highly
recommended, but some basic SDL concepts will be covered in this document.</p>

</blockquote>

<hr size=1 noshade>

<h2>Interfaces</h2>

<blockquote>

<p>Those who create 'Magic' tool plugins for Tux&nbsp;Paint must provide
some interfaces (C functions) that Tux&nbsp;Paint may invoke.</p>

<p>Tux Paint utilizes SDL's "SDL_LoadObject()" and "SDL_LoadFunction()"
routines to load plugins (shared objects files; e.g., "<code>.so</code>"
files on Linux or "<code>.dll</code>" files on Windows) and find the
functions within.</p>

<p>In turn, Tux Paint provides a number of helper functions that the
plugin may (or sometimes should) use.  This is exposed as a C structure
(containing pointers to functions inside Tux&nbsp;Paint and other data)
that gets passed along to the plugin's functions as an argument.</p>

<p>Plugins should <code>#include</code> the file "<code>tp_magic_api.h</code>",
and compiler flags which should be used when building plugins (to find the
aforementioned header file, as well as SDL's header files) can be acquired
by invoking the tool "<code>tp-magic-config</code>".</p>

<p>(These are included with Tux&nbsp;Paint &mdash; or in some cases, as part
of a "Tux&nbsp;Paint 'Magic' Tool Plugin Development package".)</p>

<h3>'Magic' tool plugin functions</h3>

<blockquote>

<p>'Magic' tool plugins must provide the functions listed below.
<b>Note:</b> To avoid namespace collisions, each function's name must
start with the shared object's filename (e.g., "blur.so" or "blur.dll"
would have functions whose names begin with "blur_").</p>

<h4>Common arguments to plugin functions:</h4>

<ul>
<li>magic_api * api<br>
  Pointer to the struct containing pointers to Tux&nbsp;Paint functions and
  other data (see below)
<li>int which<br>
  An index the plugin should use to differentiate different 'Magic' tools,
  if the plugin provides more than one.  (If not, "which" will always be 0.)
<li>SDL_Surface * canvas<br>
  The active Tux&nbsp;Paint drawing canvas.  Your magical effects should end
  up here!
<li>SDL_Surface * last<br>
  A snapshot of the previous Tux&nbsp;Paint canvas, taken when the the
  mouse was first clicked to activate the magic tool.  If you don't
  continuously affect the image during one hold of the mouse button,
  you should base your effects off the contents of this canvas.
</ul>

<h4>Required plugin functions:</h4>

<ul>
<li>int get_tool_count(magic_api * api)<br>
  This should return the number of Magic tools this plugin provides to
  Tux Paint.

<li>char * get_name(magic_api * api, int which)<br>
  This should return a string containing the name of a magic tool.
  This will appear on the button in the 'Magic' selector within Tux&nbsp;Paint.
  Tux Paint will <code>free()</code> the string upon exit, so you should
  wrap it in a C <code>strdup()</code> call.

<li>SDL_Surface * get_icon(magic_api * api, int which)<br>
  This should return an SDL_Surface containing the icon representing
  the tool.  (A greyscale image with alpha, no larger than 40x40.)
  This will appear on the button in the 'Magic' selector within
  Tux&nbsp;Paint.<br>
  Tux Paint will SDL_FreeSurface() the surface upon exit.

<li>char * get_description(magic_api * api, int which)<br>
  This should return a string containing the description of a magic tool.
  This will appear as a help tip, explained by Tux the Penguin, within
  Tux&nbsp;Paint.<br>
  Tux Paint will <code>free()</code> the string upon exit, so you should
  wrap it in a C <code>strdup()</code> call.

<li>int requires_colors(magic_api * api, int which)<br>
  Return a '1' if the 'Magic' tool accepts colors (the 'Colors' palette in
  Tux&nbsp;Paint will be available), or '0' if not.

<li>void set_color(magic_api * api, Uint8 r, Uint8 g, Uint8 g)<br>
  Tux&nbsp;Paint will call this function to inform the plugin of the
  RGB values of the currently-selected color in Tux&nbsp;Paint's
  'Colors' palette.  (It will be called whenever one of the plguin's
  Magic tools that accept colors becomes active, or the user picks a new
  color while such a tool is currently active.)

<li>Uint32 api_version(void)<br>
  The plugin should return an integer value representing the version of
  the Tux&nbsp;Paint 'Magic' tool plugin API it was built against.
  Simply return TP_MAGIC_API_VERSION, which is defined in
  "tp_magic_api.h", to satisfy this requirement.

<li>int init(magic_api * api)<br>
  The plugin should do any initialization here.  This function is called once,
  at Tux&nbsp;Paint startup.  Return '1' if initialization was successful,
  or '0' if not (and Tux&nbsp;Paint will not present any 'Magic' tools
  from the plugin).

<li>void shutdown(magic_api * api)<br>
  The plugin should do any cleanup here.  This function is called once,
  at Tux&nbsp;Paint exit.

<li>void click(magic_api * api, int which, SDL_Surface * snapshot,
    SDL_Surface * canvas, int x, int y)<br>
  The plugin should apply the appropriate 'Magic' tool on the 'canvas'
  surface.  The (x,y) coordinates are where the mouse was (within the canvas)
  when the mouse button was clicked.<br>
  The contents of the drawing canvas immediately prior to the mouse button
  click is stored within the 'snapshot' canvas.

<li>void drag(magic_api * api, int which, SDL_Surface * snapshot,
    SDL_Surface * canvas, int ox, int oy, int x, int y)<br>
  The plugin should apply the appropriate 'Magic' tool on the 'canvas'
  surface.  The (ox,oy) and (x,y) coordinates are the location of the mouse
  at the beginning and end of the stroke.  Typically, plugins that let the
  user "draw" effects onto the canvas call the Tux&nbsp;Paint 'Magic' tool
  plugin "line()" helper function. (See below).<br>
  Note: The contents of the drawing canvas immediately prior to the mouse
  button click remains as it was (when the plugin's "click()" function was
  called), and is still available in the 'snapshot' canvas.

</blockquote>

<h3>Tux Paint Functions</h3>

<blockquote>

<p>Tux&nbsp;Paint provides a number of helper functions that plugins may
access via the "magic_api" structure, sent to all of the plugin's functions
(see above).</p>

<ul>
<li>Uint32 getpixel(SDL_Surface * surf, int x, int y)
  Retreives the pixel value from the (x,y) coordinates of an SDL_Surface.
  (You can use SDL's "SDL_GetRGB()" function to convert the Uint32 'pixel'
  to a set of Uint8 RGB values.)

<li>void putpixel(SDL_Surface * surf, int x, int y, Uint32 pixel)<br>
  Sets the pixel value at position (x,y) of an SDL_Surface.
  (You can use SDL's "SDL_MapRGB()" function to convert a set of Uint8
  RGB values to a Uint32 'pixel' value appropriate to the destination
  surface.)

<li>int in_circle(int x, int y, int radius)<br>
  Returns '1' if the (x,y) location is within a circle of a particular
  radius (centered around the origin: (0,0)).  Returns '0' otherwise.
  Useful to create 'Magic' tools that affect the canvas with a circular
  brush shape.

<li>void show_progress_bar(void)<br>
  Asks Tux&nbsp;Paint to animate and draw one frame of its progress bar
  (at the bottom of the screen).  Useful for routines that may take a
  long time, to provide feedback to the user that Tux&nbsp;Paint has not
  crashed or frozen.

<li>void tuxpaint_version(int * major, int * minor, int * revision)<br>
  Returns the version of Tux Paint being used (e.g., "0.9.18"),
  separated into three integers.

<li>void line(int which, SDL_Surface * canvas, SDL_Surface * snapshot,
  int x1, int y1, int x2, int y2, int step, FUNC callback)<br>
  This function calculates all points on a line between the coordinates
  (x1,y1) and (x2,y2).  Every 'step' iterations, it calls the 'callback'
  function.<br>
  It sends the 'callback' function the (x,y) coordinates on the line,
  Tux&nbsp;Paint's "magic_api" struct (as a "void&nbsp;*" pointer),
  a 'which' value, represening which of the plugin's 'Magic' tool is
  being used, and the current and snapshot canvases.<br>

  <p>Example prototype of a callback function that may be sent to
  Tux&nbsp;Paint's "line()" 'Magic' tool plugin helper function:</p>

  <blockquote>
    <p><code>void exampleCallBack(void * ptr_to_api, int which_tool,
    SDL_Surface * canvas, SDL_Surface * snapshot, int x, int y);</code></p>
  </blockquote>

<li>void playsound(Mix_Chunk * snd, int pan, int dist)<br>
  This function plays a sound (one loaded by the SDL helper library
  "SDL_mixer").  It uses SDL_mixer's "Mix_SetPanning()" to set the volume
  of the sound on the left and right speakers, based on the 'pan' and 'dist'
  values sent to it.<br>
  A 'pan' of 128 causes the sound to be played at equal volume on the left
  and right speakers.  A 'pan' of 0 causes it to be played completely on the
  left, and 255 completely on the right.<br>
  The 'dist' value affects overall volume.  255 is loudest, and 0 is silent.<br>
  The 'pan' and 'dist' values can be used to simulate location and distance of
  the 'Magic' tool effect.

<li>void special_notify(int flag)<br>
  This function notifies Tux&nbsp;Paint of special events.  Various values
  defined in "tp_magic_api.h" can be logically 'or'ed together and sent to
  this function.
  <ul>
  <li>SPECIAL_FLIP &mdash; The contents of the canvas has been flipped.
    If a 'Starter' image was used as the basis of this image, it should be
    flipped too, and a record of the flip should be stored as part of
    Tux&nbsp;Paint's undo buffer stack.  Additionally, the fact that the
    starter has been flipped (or unflipped) should be recorded on disk
    when the current drawing is saved.
  <li>SPECIAL_MIRROR &mdash; Similar to SPECIAL_FLIP, but for magic tools
    that mirror the contents of the canvas.
  </ul>

  <li>int button_down(void)<br>
    A '1' is returned if the mouse button is down; '0' otherwise.

  <li>float sRGB_to_linear(Uint8 srbg)<br>
    Converts an 8-bit sRGB value (one between 0 and 255) to a linear
    floating point value (between 0.0 and 1.0).

  <li>uint8 linear_to_sRGB(float linear)<br>
    Converts a linear floating point value (one between 0.0 and 1.0) to
    an 8-bit sRGB value (between 0 and 255).
  </ul>

</blockquote>

</blockquote>

<hr size=1 noshade>

<h2>Compiling</h2>

<blockquote>

  <h3>Linux and other Unix-like Platforms</h3>

  <blockquote>

  <p>Use the C compiler's "-shared" command-line option to generate
  a shared object file ("<code>.so</code>") based on your 'Magic' tool
  plugin's C source code.</p>

  <p>Additionally, use the "tp-magic-config&nbsp;--cflags" command,
  supplied as part of Tux&nbsp;Paint, to provide additional command-line
  flags to your C compiler that will help it build your plugin.</p>

  <p>As a stand-alone command, using the GNU C Compiler and BASH shell,
  for example:</p>

  <blockquote>
    <p><code>
      gcc -shared `tp-magic-config --cflags` my_plugin.c -o my_plugin.so
    </code></p>
  </blockquote>

  <p>A snippet from a more generalized Makefile might look like this:</p>

  <blockquote>
    <p><code>
      CFLAGS=-Wall -O2 $(shell tp-magic-config --cflags)<br>
      <br>
      my_plugin.so:  my_plugin.c
      &nbsp;&nbsp;&nbsp;$(CC) -shared $(CFLAGS) -o $@ $&lt;
    </code></p>
  </blockquote>

  <p>Then install globally into:  /usr/[local/]lib/tuxpaint/.
  Or locally into:  ~/.tuxpaint/magic/</p>

  </blockquote>

  <h3>Windows</h3>

  <blockquote>
  <p>TBD</p>
  </blockquote>

  <h3>Mac OS X</h3>

  <blockquote>
  <p>TBD</p>
  </blockquote>

</blockquote>

<hr size=1 noshade>

<h2>Example Code</h2>

<blockquote>
</blockquote>

<hr size=1 noshade>

<p>Summary and contact info TBD.</p>

</body></html>

